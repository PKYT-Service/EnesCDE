 <div id="app"></div>
    <div id="tools"></div>
    <div id="object"></div>
    <div id="transform">
        <div class="tp-rotv tp-cntv tp-rotv-expanded tp-rotv-cpl tp-rotv-not">
            <div class="tp-brkv tp-rotv_c" style="height: auto;">
                <div class="tp-lblv tp-lblv-nol tp-v-fst tp-v-vfst">
                    <div class="tp-lblv_l"></div>
                    <div class="tp-lblv_v">
                        <div class="tp-btnv"><button class="tp-btnv_b transform_btn" user-data='translate'><div class="tp-btnv_t">translate</div></button></div>
                    </div>
                </div>
                <div class="tp-lblv tp-lblv-nol">
                    <div class="tp-lblv_l"></div>
                    <div class="tp-lblv_v">
                        <div class="tp-btnv"><button class="tp-btnv_b transform_btn" user-data='rotate'><div class="tp-btnv_t">rotate</div></button></div>
                    </div>
                </div>
                <div class="tp-lblv tp-lblv-nol tp-v-lst tp-v-vlst">
                    <div class="tp-lblv_l"></div>
                    <div class="tp-lblv_v">
                        <div class="tp-btnv"><button class="tp-btnv_b transform_btn" user-data='scale'><div class="tp-btnv_t">scale</div></button></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<style>
  
  body {
  padding: 0;
  margin: 0;
}

#app {
  position: fixed;
  left: 0;
}
#tools {
  position: fixed;
  right: 0;
}

#object {
  position: fixed;
  bottom: 0;
  right: 0;
}
#transform {
  position: fixed;
  bottom: 24px;
  left: 45%;
}

  
</style>


<script>const PARAMS = {
  scene: {
    background: "black"
  },
  helper: {
    gridHelper: {
      toggle: true,
      size: 100,
      divisions: 100
    }
  },
  camera: {
    fov: 65,
    aspect: window.innerWidth / window.innerHeight,
    near: 0.1,
    far: 1000,
    position: {
      x: 6,
      y: 12,
      z: 10
    },
    lookAt: {
      x: 0,
      y: 0,
      z: 0
    }
  },
  transform: [true, false, false]
};

const toolsPane = new Tweakpane.Pane({
  title: "Tools",
  container: document.getElementById("tools"),
  expanded: true
});

const f1 = toolsPane.addFolder({
  title: "Scene",
  expanded: false
});
f1.addInput(PARAMS.scene, "background").on("change", (e) => {
  console.log("changed: ", new THREE.Color(e.value), PARAMS);
  scene.background = new THREE.Color(e.value);
});
const f2 = toolsPane.addFolder({
  title: "Helper",
  expanded: false
});
f2.addInput(PARAMS.helper.gridHelper, "toggle", {
  title: "on",
  label: "gridHelper"
}).on("change", (e) => {
  console.log(e.value);
  if (e.value) {
    addGridHelper(
      PARAMS.helper.gridHelper.size,
      PARAMS.helper.gridHelper.divisions
    );
  } else {
    Array.from(
      scene.children.filter((f) => f.type === "GridHelper"),
      (c) => c.removeFromParent()
    );
  }
});
f2.addInput(PARAMS.helper.gridHelper, "size", {
  title: "on",
  label: "size",
  min: 0,
  max: 100,
  step: 1
}).on("change", (e) => {
  console.log(e.value);
  if (PARAMS.helper.gridHelper.toggle) {
    Array.from(
      scene.children.filter((f) => f.type === "GridHelper"),
      (c) => c.removeFromParent()
    );
    addGridHelper(
      PARAMS.helper.gridHelper.size,
      PARAMS.helper.gridHelper.divisions
    );
  }
});
f2.addInput(PARAMS.helper.gridHelper, "divisions", {
  title: "on",
  label: "divisions",
  min: 0,
  max: 100,
  step: 1
}).on("change", (e) => {
  console.log(e.value);
  if (PARAMS.helper.gridHelper.toggle) {
    Array.from(
      scene.children.filter((f) => f.type === "GridHelper"),
      (c) => c.removeFromParent()
    );
    addGridHelper(
      PARAMS.helper.gridHelper.size,
      PARAMS.helper.gridHelper.divisions
    );
  }
});
const f3 = toolsPane
  .addFolder({
    title: "Camera",
    expanded: true // optional
  })
  .on("change", (e) => {
    // console.log("changed: ", e.value, e);
    if (e.presetKey === "position") {
      camera.position.set(e.value.x, e.value.y, e.value.z);
    } else if (e.presetKey === "lookAt") {
      //bug 不生效
      camera.lookAt(e.value.x, e.value.y, e.value.z);
      // console.log("changed: ", e.value, e);
    } else {
      camera[e.presetKey] = e.value;
    }
    camera.updateProjectionMatrix();
  });
f3.addInput(PARAMS.camera, "fov", {
  min: 0,
  max: 100,
  step: 1
});
// f2.addInput(PARAMS.camera, "aspect");
f3.addInput(PARAMS.camera, "near", {
  min: 0,
  max: 100,
  step: 1
});
f3.addInput(PARAMS.camera, "far", {
  min: 0,
  max: 1000,
  step: 1
});
f3.addInput(PARAMS.camera, "position", {
  x: {
    step: 1
  },
  y: {
    step: 1
  },
  z: {
    max: 10,
    step: 1
  }
});
f3.addInput(PARAMS.camera, "lookAt", {
  x: {
    step: 1
  },
  y: {
    step: 1
  },
  z: {
    step: 1
  }
});

Array.from(document.querySelectorAll(".transform_btn"), (b) => {
  b.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (transformControl) {
      // if (!window._transformControlObject && transformControl.object) window._transformControlObject = transformControl.object;
      transformControl.setMode(b.getAttribute("user-data"));
      if (window._transformControlObject)
        transformControl.attach(window._transformControlObject);
    }
  });
});

const appPane = new Tweakpane.Pane({
  title: "App",
  container: document.getElementById("app"),
  expanded: true
});

appPane
  .addButton({
    title: "new"
    // label: 'counter',   // optional
  })
  .on("click", () => {
    // console.log(9);
  });

appPane
  .addButton({
    title: "load"
    // label: 'counter',   // optional
  })
  .on("click", () => {
    var inputFile = document.createElement("input");
    inputFile.type = "file";
    inputFile.addEventListener("change", (e) => loadFile(inputFile.files[0]));
    inputFile.click();
  });

appPane
  .addButton({
    title: "cube"
    // label: 'counter',   // optional
  })
  .on("click", () => {
    let cube = addCube();
    scene.add(cube);
    transformControlObjects.push(cube);
  });

function loadFile(file) {
  const filename = file.name;
  const extension = filename.split(".").pop().toLowerCase();

  const reader = new FileReader();
  reader.addEventListener("progress", function (event) {
    // console.log(event);
    const size = "(" + Math.floor(event.total / 1000) + " KB)";
    const progress = Math.floor((event.loaded / event.total) * 100) + "%";
    console.log("Loading", filename, size, progress);
  });
  switch (extension) {
    case "glb": {
      reader.addEventListener(
        "load",
        async function (event) {
          const contents = event.target.result;

          const dracoLoader = new THREE.DRACOLoader();
          dracoLoader.setDecoderPath(
            "https://unpkg.com/three@0.139.0/examples/js/libs/draco/gltf"
          );

          const loader = new THREE.GLTFLoader();
          loader.setDRACOLoader(dracoLoader);
          loader.parse(contents, "", function (result) {
            const loadedScene = result.scene;
            loadedScene.name = filename;
            loadedScene.animations.push(...result.animations);
            AddObjectCommand(loadedScene);
          });
        },
        false
      );
      reader.readAsArrayBuffer(file);

      break;
    }
  }
}

function AddObjectCommand(newScene) {
  //   bug 物体不居中
  const group = new THREE.Group();
  group.add(newScene);
  // group.scale.multiplyScalar( 50 );
  scene.add(group);

  transformControlObjects.push(group);
  console.log(transformControlObjects);
  // To make sure that the matrixWorld is up to date for the boxhelpers
  // group.updateMatrixWorld(true);
  // let boxHelper = new THREE.BoxHelper(group);
  // group.add(boxHelper);
  // // group.add(mesh);
  // boxHelper.geometry.computeBoundingBox();
  // // console.log(boxHelper.geometry);
  // group.add(
  //   addCube("helper_cube", boxHelper.geometry.boundingBox.min, [0.2, 0.2, 0.2])
  // );
  // toggleObjectPane(group);
}

// object pane
function toggleObjectPane(object) {
  if (window._objectPane) window._objectPane.dispose();
  window._objectPane = new Tweakpane.Pane({
    title: "Object",
    container: document.getElementById("object"),
    expanded: true
  });
  window._objectPane
    .addInput(object, "position", {
      x: {
        step: 1
      },
      y: {
        step: 1
      },
      z: {
        step: 1
      }
    })
    .on("change", (e) => console.log(e.value));

  window._objectPane
    .addInput(object, "scale")
    .on("change", (e) => console.log(e.value));
}

// 场景
const scene = new THREE.Scene();
scene.background = new THREE.Color(PARAMS.scene.background);
// 摄像机
const camera = new THREE.PerspectiveCamera(
  PARAMS.camera.fov,
  PARAMS.camera.aspect,
  PARAMS.camera.near,
  PARAMS.camera.far
);
camera.position.set(
  PARAMS.camera.position.x,
  PARAMS.camera.position.y,
  PARAMS.camera.position.z
);
camera.lookAt(
  PARAMS.camera.lookAt.x,
  PARAMS.camera.lookAt.y,
  PARAMS.camera.lookAt.z
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 控制
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.update();

controls.addEventListener("change", (e) => {
  PARAMS.camera.position = controls.object.position;
  toolsPane.importPreset(PARAMS.camera);
  // transformControl.detach();
  // transformControl.enabled = false;
});
controls.addEventListener("end", () => {
  // setTimeout(() => (transformControl.enabled = true), 500)
});

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
const onUpPosition = new THREE.Vector2();
const onDownPosition = new THREE.Vector2();

const transformControlObjects = [];
let transformControlTarget = null;
const transformControl = new THREE.TransformControls(
  camera,
  renderer.domElement
);
transformControl.setSize(1);
// "translate", "rotate" and "scale".
transformControl.setMode("rotate");
transformControl.addEventListener("change", (e) => {
  // renderer.render(scene, camera);
  // console.log(e.type, transformControl.mode);
  // mouseCursor('move');
});

transformControl.addEventListener("dragging-changed", function (event) {
  controls.enabled = !event.value;
});
scene.add(transformControl);

transformControl.addEventListener("objectChange", function () {
  // updateSplineOutline();
});

document.addEventListener("pointerdown", onPointerDown);
document.addEventListener("pointerup", onPointerUp);
document.addEventListener("pointermove", onPointerMove);

// const geometry = new THREE.BoxGeometry(1, 1, 1);
// const material = new THREE.MeshBasicMaterial({ color: "white" });
// const cube = new THREE.Mesh(geometry, material);
// scene.add(cube);

// transformControlObjects.push(cube);

function onPointerDown(event) {
  onDownPosition.x = event.clientX;
  onDownPosition.y = event.clientY;
}

function onPointerUp() {
  onUpPosition.x = event.clientX;
  onUpPosition.y = event.clientY;
  if (transformControlTarget && transformControl.enabled) {
    window._transformControlObject = transformControlTarget;
    transformControl.attach(transformControlTarget);
  }

  if (
    onDownPosition.distanceTo(onUpPosition) === 0 &&
    !transformControlTarget
  ) {
    window._transformControlObject = null;
    transformControl.detach();
  }
}

function onPointerMove(event) {
  pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(pointer, camera);

  const intersects = raycaster.intersectObjects(transformControlObjects, true);

  if (intersects.length > 0 && !transformControl.object) {
    const object = intersects[0].object;
    transformControlTarget = object;
    // transformControl.attach(transformControlTarget);
    let group = new THREE.Group();
    group.name = "BoxHelper";
    group.scale.set(1.2, 1.2, 1.2);
    let oc = object.clone();
    oc.visible = false;
    group.add(oc);
    group.updateMatrixWorld(true);
    scene.add(group);
    let boxHelper = new THREE.BoxHelper(group);
    group.add(boxHelper);
    mouseCursor();
  } else {
    // transformControl.detach();
    transformControlTarget = null;
    Array.from(
      scene.children.filter((f) => f.name === "BoxHelper"),
      (c) => c.removeFromParent()
    );
    // scene.add(boxHelperGroup.children[0])
    mouseCursor("auto");
  }
}

// 辅助
if (PARAMS.helper.gridHelper.toggle)
  addGridHelper(
    PARAMS.helper.gridHelper.size,
    PARAMS.helper.gridHelper.divisions
  );

function addGridHelper(size = 100, divisions = 100) {
  const gridHelper = new THREE.GridHelper(size, divisions);
  scene.add(gridHelper);
}

function mouseCursor(value = "pointer") {
  renderer.domElement.style.cursor = value;
}

// 添加物品
function addCube(
  name = "cube",
  position = {
    x: 0,
    y: 0,
    z: 0
  },
  size = [1, 1, 1]
) {
  const b_geometry = new THREE.BoxGeometry(...size);
  const m_material = new THREE.MeshBasicMaterial({
    color: new THREE.Color(1, 0, 0)
  });
  const cube = new THREE.Mesh(b_geometry, m_material);
  cube.name = name;
  cube.position.set(position.x, position.y, position.z);
  //scene.add(cube);
  return cube;
}

// const points = [];
// points.push(new THREE.Vector3(-10, 0, 0));
// points.push(new THREE.Vector3(0, 10, 0));
// points.push(new THREE.Vector3(10, 0, 0));

// const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
// const line = new THREE.Line(lineGeometry, material);
// scene.add(line);

window.addEventListener("resize", onWindowResize);

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  // required if controls.enableDamping or controls.autoRotate are set to true
  controls.update();
  renderer.render(scene, camera);
}

animate();
</script>
